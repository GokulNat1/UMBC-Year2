// CMSC 341 - Fall 2020 - Project 3// PQueue: an ER triage queue using a skew heap and function pointers#include "pqueue.h"using namespace std;using std::cout;using std::endl;using std::domain_error;PQueue::PQueue(prifn_t priFn) {    _heap = nullptr;    _size = 0;    priority = priFn;}PQueue::~PQueue() {    if (_heap)    {        delete(_heap);    }}PQueue::PQueue(const PQueue& rhs) {    if(rhs._heap == nullptr)    {        this->_heap = nullptr;    }    else    {        this->_heap = rhs._heap;        this->_size = rhs._size;    }}PQueue& PQueue::operator=(const PQueue& rhs) {    if(rhs._heap == nullptr)    {        this->_heap = nullptr;    }    else    {        this->_heap = rhs._heap;        this->_size = rhs._size;    }    return *this;}void PQueue::insertPatient(const Patient& input) {    Node* temp = new Node(input);    if (_heap == nullptr){        _heap = temp;    }    else{        Node* aNode = new Node(input);        _heap = mergeHelp(_heap, aNode);    }    _size = _size + 1;}Patient PQueue::getNextPatient() {    if (_heap == nullptr){         throw "ill";    }    else{        Patient aPatient = _heap->_patient;        Node *temp1,*temp2;        temp1 = _heap->_left;        temp2 = _heap->_right;        temp1 = mergeHelp(temp1,temp2);        _heap = temp1;        return aPatient;    }}void PQueue::mergeWithQueue(PQueue &rhs) {    if (this->getPriorityFn() != rhs.getPriorityFn()){        throw "PQueues don't match priority";    }    Node* newNode;    newNode = mergeHelp(_heap, rhs._heap);    _heap = newNode;}Node* PQueue::mergeHelp(Node* node1, Node* node2){    Node* temp;    if (node1 == nullptr)        return node2;    else if (node2 == nullptr)        return node1;    else    {        if ( priority(node1->getPatient()) > priority(node2->getPatient()) )        {            temp = node1;            node1 = node2;            node2 = temp;        }        temp = node1->_left;        node1->_left = node1->_right;        node1->_right= temp;        node1->_left = mergeHelp(node2,node1->_left);        return node1;    }}void PQueue::clear() {    _heap = nullptr;    _size = 0;}int PQueue::numPatients() {    return _size;}int PQueue::numPatientsHelp(Node* aNode) {    if (aNode == nullptr) {        _size = 0;    }    else {        numPatientsHelp(aNode->_left);        numPatientsHelp(aNode->_right);        _size = _size + 1;    }    return _size;}void PQueue::printPatientQueue() const {    printPatientQueue(_heap);}void PQueue::printPatientQueue(Node* aNode) const{    if (aNode == nullptr) {        return;    }    else {        cout << "[" << priority(aNode->getPatient()) << "] ";        cout << aNode->_patient;        cout << endl;        printPatientQueue(aNode->_left);        printPatientQueue(aNode->_right);        return;    }}prifn_t PQueue::getPriorityFn() const {    return *priority;}void PQueue::setPriorityFn(prifn_t priFn) {    priority = priFn;    PQueue *tempQueue = new PQueue(priority);}void PQueue::setPriorityFnHelp(Node* aNode, prifn_t priFn){    priority = priFn;    PQueue* tempQueue = new PQueue(priority);    if (aNode == nullptr) {        return;    }    else {        tempQueue->insertPatient(aNode->getPatient());        setPriorityFnHelp(aNode->_left, priority);        setPriorityFnHelp(aNode->_right, priority);    }    _heap = tempQueue->_heap;}void PQueue::dump() const {    inOrder(_heap);    cout << endl;}void PQueue::inOrder(Node* aNode) const {    if (aNode == nullptr) {        return;    }    else {        cout << "(";        inOrder(aNode->_left);        cout << aNode->_patient.getTriage() << ":" << aNode->_patient.getPatient();        inOrder(aNode->_right);        cout << ")";    }    return;}ostream& operator<<(ostream& sout, const Patient& patient) {    sout << "Patient: " << patient.getPatient() << ", triage: " << patient.getTriage()         << ", temperature: " << patient.getTemperature() << ", oxygen: " << patient.getOxygen() << ", RR: "         << patient.getRR() << ", HR: " << patient.getHR() << ", BP: " << patient.getBP();    return sout;}ostream& operator<<(ostream& sout, const Node& node) {    sout << node.getPatient();    return sout;}